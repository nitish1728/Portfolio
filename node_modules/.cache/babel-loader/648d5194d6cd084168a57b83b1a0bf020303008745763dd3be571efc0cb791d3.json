{"ast":null,"code":"import _defineProperty from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _wrapAsyncGenerator from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nconst _excluded = [\"accessToken\", \"endpointUrl\"];\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign({}, ...props.map(prop => {\n    if (o[prop] !== void 0) {\n      return {\n        [prop]: o[prop]\n      };\n    }\n  }));\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter(prop => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = \"\".concat(model, \":\").concat(accessToken);\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    var _options$fetch;\n    const modelTask = await ((_options$fetch = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch !== void 0 ? _options$fetch : fetch)(\"\".concat(HF_HUB_URL, \"/api/models/\").concat(model, \"?expand[]=pipeline_tag\"), {\n      headers: accessToken ? {\n        Authorization: \"Bearer \".concat(accessToken)\n      } : {}\n    }).then(resp => resp.json()).then(json => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    };\n    taskCache.set(key, {\n      task: modelTask,\n      date: /* @__PURE__ */new Date()\n    });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const {\n      accessToken,\n      endpointUrl\n    } = args,\n    otherArgs = _objectWithoutProperties(args, _excluded);\n  let {\n    model\n  } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options !== null && options !== void 0 ? options : {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = \"Bearer \".concat(accessToken);\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(\"\".concat(HF_HUB_URL, \"/api/tasks\"));\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return \"\".concat(HF_INFERENCE_API_BASE_URL, \"/pipeline/\").concat(task, \"/\").concat(model);\n    }\n    return \"\".concat(HF_INFERENCE_API_BASE_URL, \"/models/\").concat(model);\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = _objectSpread(_objectSpread({\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify(_objectSpread({}, otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs))\n  }, credentials && {\n    credentials\n  }), {}, {\n    signal: options === null || options === void 0 ? void 0 : options.signal\n  });\n  return {\n    url,\n    info\n  };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  var _options$fetch2, _response$headers$get2;\n  const {\n    url,\n    info\n  } = await makeRequestOptions(args, options);\n  const response = await ((_options$fetch2 = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch2 !== void 0 ? _options$fetch2 : fetch)(url, info);\n  if ((options === null || options === void 0 ? void 0 : options.retry_on_error) !== false && response.status === 503 && !(options !== null && options !== void 0 && options.wait_for_model)) {\n    return request(args, _objectSpread(_objectSpread({}, options), {}, {\n      wait_for_model: true\n    }));\n  }\n  if (!response.ok) {\n    var _response$headers$get;\n    if ((_response$headers$get = response.headers.get(\"Content-Type\")) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options !== null && options !== void 0 && options.chatCompletion) {\n        throw new Error(\"Server \".concat(args.model, \" does not seem to support chat completion. Error: \").concat(output.error));\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if ((_response$headers$get2 = response.headers.get(\"Content-Type\")) !== null && _response$headers$get2 !== void 0 && _response$headers$get2.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage === null || onMessage === void 0 || onMessage(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nfunction streamingRequest(_x, _x2) {\n  return _streamingRequest.apply(this, arguments);\n} // src/lib/InferenceOutputError.ts\nfunction _streamingRequest() {\n  _streamingRequest = _wrapAsyncGenerator(function* (args, options) {\n    var _options$fetch3, _response$headers$get4;\n    const {\n      url,\n      info\n    } = yield _awaitAsyncGenerator(makeRequestOptions(_objectSpread(_objectSpread({}, args), {}, {\n      stream: true\n    }), options));\n    const response = yield _awaitAsyncGenerator(((_options$fetch3 = options === null || options === void 0 ? void 0 : options.fetch) !== null && _options$fetch3 !== void 0 ? _options$fetch3 : fetch)(url, info));\n    if ((options === null || options === void 0 ? void 0 : options.retry_on_error) !== false && response.status === 503 && !(options !== null && options !== void 0 && options.wait_for_model)) {\n      return yield* _asyncGeneratorDelegate(_asyncIterator(streamingRequest(args, _objectSpread(_objectSpread({}, options), {}, {\n        wait_for_model: true\n      }))), _awaitAsyncGenerator);\n    }\n    if (!response.ok) {\n      var _response$headers$get3;\n      if ((_response$headers$get3 = response.headers.get(\"Content-Type\")) !== null && _response$headers$get3 !== void 0 && _response$headers$get3.startsWith(\"application/json\")) {\n        const output = yield _awaitAsyncGenerator(response.json());\n        if ([400, 422, 404, 500].includes(response.status) && options !== null && options !== void 0 && options.chatCompletion) {\n          throw new Error(\"Server \".concat(args.model, \" does not seem to support chat completion. Error: \").concat(output.error));\n        }\n        if (output.error) {\n          throw new Error(output.error);\n        }\n      }\n      throw new Error(\"Server response contains error: \".concat(response.status));\n    }\n    if (!((_response$headers$get4 = response.headers.get(\"content-type\")) !== null && _response$headers$get4 !== void 0 && _response$headers$get4.startsWith(\"text/event-stream\"))) {\n      throw new Error(\"Server does not support event stream content type, it returned \" + response.headers.get(\"content-type\"));\n    }\n    if (!response.body) {\n      return;\n    }\n    const reader = response.body.getReader();\n    let events = [];\n    const onEvent = event => {\n      events.push(event);\n    };\n    const onChunk = getLines(getMessages(() => {}, () => {}, onEvent));\n    try {\n      while (true) {\n        const {\n          done,\n          value\n        } = yield _awaitAsyncGenerator(reader.read());\n        if (done) return;\n        onChunk(value);\n        for (const event of events) {\n          if (event.data.length > 0) {\n            if (event.data === \"[DONE]\") {\n              return;\n            }\n            const data = JSON.parse(event.data);\n            if (typeof data === \"object\" && data !== null && \"error\" in data) {\n              throw new Error(data.error);\n            }\n            yield data;\n          }\n        }\n        events = [];\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  });\n  return _streamingRequest.apply(this, arguments);\n}\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\"Invalid inference output: \".concat(message, \". Use the 'request' method with the same parameters to do a custom call with no type checking.\"));\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"audio-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"automatic-speech-recognition\"\n  }));\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.text) === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"text-to-speech\"\n  }));\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"audio-to-audio\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"image-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"image-segmentation\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  var _await$request;\n  const res = (_await$request = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"image-to-text\"\n  }))) === null || _await$request === void 0 ? void 0 : _await$request[0];\n  if (typeof (res === null || res === void 0 ? void 0 : res.generated_text) !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"object-detection\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"text-to-image\"\n  }));\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach(byte => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = _objectSpread(_objectSpread({}, args), {}, {\n      inputs: base64FromBytes(new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer()))\n    });\n  }\n  const res = await request(reqArgs, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"image-to-image\"\n  }));\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = _objectSpread(_objectSpread({}, args), {}, {\n    inputs: {\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  });\n  const res = await request(reqArgs, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"zero-shot-image-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"feature-extraction\"\n  }, defaultTask === \"sentence-similarity\" && {\n    forceTask: \"feature-extraction\"\n  }));\n  let isValidOutput = true;\n  const isNumArrayRec = function (arr, maxDepth) {\n    let curDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (curDepth > maxDepth) return false;\n    if (arr.every(x => Array.isArray(x))) {\n      return arr.every(x => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every(x => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"fill-mask\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"question-answering\"\n  }));\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"sentence-similarity\"\n  }, defaultTask === \"feature-extraction\" && {\n    forceTask: \"sentence-similarity\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"summarization\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.summary_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res === null || res === void 0 ? void 0 : res[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"table-question-answering\"\n  }));\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.aggregator) === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every(x => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every(coord => Array.isArray(coord) && coord.every(x => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  var _await$request2;\n  const res = (_await$request2 = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"text-classification\"\n  }))) === null || _await$request2 === void 0 ? void 0 : _await$request2[0];\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.label) === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"text-generation\"\n  })));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.generated_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res === null || res === void 0 ? void 0 : res[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nfunction textGenerationStream(_x3, _x4) {\n  return _textGenerationStream.apply(this, arguments);\n} // src/tasks/nlp/tokenClassification.ts\nfunction _textGenerationStream() {\n  _textGenerationStream = _wrapAsyncGenerator(function* (args, options) {\n    yield* _asyncGeneratorDelegate(_asyncIterator(streamingRequest(args, _objectSpread(_objectSpread({}, options), {}, {\n      taskHint: \"text-generation\"\n    }))), _awaitAsyncGenerator);\n  });\n  return _textGenerationStream.apply(this, arguments);\n}\nasync function tokenClassification(args, options) {\n  const res = toArray(await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"token-classification\"\n  })));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"translation\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof (x === null || x === void 0 ? void 0 : x.translation_text) === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return (res === null || res === void 0 ? void 0 : res.length) === 1 ? res === null || res === void 0 ? void 0 : res[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"zero-shot-classification\"\n  })));\n  const isValidOutput = Array.isArray(res) && res.every(x => Array.isArray(x.labels) && x.labels.every(_label => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every(_score => typeof _score === \"number\") && typeof x.sequence === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  }));\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res === null || res === void 0 ? void 0 : res.choices) && typeof (res === null || res === void 0 ? void 0 : res.created) === \"number\" && typeof (res === null || res === void 0 ? void 0 : res.id) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.model) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.system_fingerprint) === \"string\" && typeof (res === null || res === void 0 ? void 0 : res.usage) === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nfunction chatCompletionStream(_x5, _x6) {\n  return _chatCompletionStream.apply(this, arguments);\n} // src/tasks/multimodal/documentQuestionAnswering.ts\nfunction _chatCompletionStream() {\n  _chatCompletionStream = _wrapAsyncGenerator(function* (args, options) {\n    yield* _asyncGeneratorDelegate(_asyncIterator(streamingRequest(args, _objectSpread(_objectSpread({}, options), {}, {\n      taskHint: \"text-generation\",\n      chatCompletion: true\n    }))), _awaitAsyncGenerator);\n  });\n  return _chatCompletionStream.apply(this, arguments);\n}\nasync function documentQuestionAnswering(args, options) {\n  var _toArray;\n  const reqArgs = _objectSpread(_objectSpread({}, args), {}, {\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  });\n  const res = (_toArray = toArray(await request(reqArgs, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"document-question-answering\"\n  })))) === null || _toArray === void 0 ? void 0 : _toArray[0];\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.answer) === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  var _await$request3;\n  const reqArgs = _objectSpread(_objectSpread({}, args), {}, {\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(new Uint8Array(args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()))\n    }\n  });\n  const res = (_await$request3 = await request(reqArgs, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"visual-question-answering\"\n  }))) === null || _await$request3 === void 0 ? void 0 : _await$request3[0];\n  const isValidOutput = typeof (res === null || res === void 0 ? void 0 : res.answer) === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"tabular-regression\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, _objectSpread(_objectSpread({}, options), {}, {\n    taskHint: \"tabular-classification\"\n  }));\n  const isValidOutput = Array.isArray(res) && res.every(x => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class HfInference {\n  constructor() {\n    let accessToken = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let defaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _defineProperty(this, \"accessToken\", void 0);\n    _defineProperty(this, \"defaultOptions\", void 0);\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn(_objectSpread(_objectSpread({}, params), {}, {\n          accessToken\n        }), _objectSpread(_objectSpread({}, defaultOptions), options))\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl) {\n    let accessToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let defaultOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fn(_objectSpread(_objectSpread({}, params), {}, {\n          accessToken,\n          endpointUrl\n        }), _objectSpread(_objectSpread({}, defaultOptions), options))\n      });\n    }\n  }\n};\nexport { HfInference, HfInferenceEndpoint, InferenceOutputError, audioClassification, audioToAudio, automaticSpeechRecognition, chatCompletion, chatCompletionStream, documentQuestionAnswering, featureExtraction, fillMask, imageClassification, imageSegmentation, imageToImage, imageToText, objectDetection, questionAnswering, request, sentenceSimilarity, streamingRequest, summarization, tableQuestionAnswering, tabularClassification, tabularRegression, textClassification, textGeneration, textGenerationStream, textToImage, textToSpeech, tokenClassification, translation, visualQuestionAnswering, zeroShotClassification, zeroShotImageClassification };","map":{"version":3,"names":["__defProp","Object","defineProperty","__export","target","all","name","get","enumerable","tasks_exports","audioClassification","audioToAudio","automaticSpeechRecognition","chatCompletion","chatCompletionStream","documentQuestionAnswering","featureExtraction","fillMask","imageClassification","imageSegmentation","imageToImage","imageToText","objectDetection","questionAnswering","request","sentenceSimilarity","streamingRequest","summarization","tableQuestionAnswering","tabularClassification","tabularRegression","textClassification","textGeneration","textGenerationStream","textToImage","textToSpeech","tokenClassification","translation","visualQuestionAnswering","zeroShotClassification","zeroShotImageClassification","pick","o","props","assign","map","prop","typedInclude","arr","v","includes","omit","propsArr","Array","isArray","letsKeep","keys","filter","isUrl","modelOrUrl","test","startsWith","taskCache","Map","CACHE_DURATION","MAX_CACHE_ITEMS","HF_HUB_URL","getDefaultTask","model","accessToken","options","key","concat","cachedTask","date","Date","now","delete","_options$fetch","modelTask","fetch","headers","Authorization","then","resp","json","pipeline_tag","catch","task","set","size","next","value","HF_INFERENCE_API_BASE_URL","tasks","makeRequestOptions","args","endpointUrl","otherArgs","_objectWithoutProperties","_excluded","forceTask","includeCredentials","taskHint","wait_for_model","use_cache","dont_load_model","chatCompletion2","res","ok","taskInfo","models","id","Error","binary","data","url","TypeError","console","warn","endsWith","credentials","info","_objectSpread","method","body","JSON","stringify","signal","_options$fetch2","_response$headers$get2","response","retry_on_error","status","_response$headers$get","output","error","blob","getLines","onLine","buffer","position","fieldLength","discardTrailingNewline","onChunk","bufLength","length","lineStart","lineEnd","subarray","getMessages","onId","onRetry","onMessage","message","newMessage","decoder","TextDecoder","line","field","decode","valueOffset","event","retry","parseInt","isNaN","a","b","Uint8Array","_x","_x2","_streamingRequest","apply","arguments","_wrapAsyncGenerator","_options$fetch3","_response$headers$get4","_awaitAsyncGenerator","stream","_asyncGeneratorDelegate","_asyncIterator","_response$headers$get3","reader","getReader","events","onEvent","push","done","read","parse","releaseLock","InferenceOutputError","constructor","isValidOutput","every","x","label","score","text","Blob","mask","_await$request","generated_text","box","xmin","ymin","xmax","ymax","base64FromBytes","globalThis","Buffer","from","toString","bin","forEach","byte","String","fromCharCode","btoa","join","reqArgs","parameters","inputs","ArrayBuffer","arrayBuffer","image","defaultTask","isNumArrayRec","maxDepth","curDepth","undefined","sequence","token","token_str","answer","end","start","summary_text","aggregator","cells","coordinates","coord","_await$request2","toArray","obj","_x3","_x4","_textGenerationStream","entity_group","word","translation_text","labels","_label","scores","_score","choices","created","system_fingerprint","usage","_x5","_x6","_chatCompletionStream","_toArray","question","_await$request3","HfInference","defaultOptions","_defineProperty","fn","entries","params","endpoint","HfInferenceEndpoint"],"sources":["C:/Users/barat/Documents/Projects/React JS/project4/node_modules/@huggingface/inference/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/tasks/index.ts\nvar tasks_exports = {};\n__export(tasks_exports, {\n  audioClassification: () => audioClassification,\n  audioToAudio: () => audioToAudio,\n  automaticSpeechRecognition: () => automaticSpeechRecognition,\n  chatCompletion: () => chatCompletion,\n  chatCompletionStream: () => chatCompletionStream,\n  documentQuestionAnswering: () => documentQuestionAnswering,\n  featureExtraction: () => featureExtraction,\n  fillMask: () => fillMask,\n  imageClassification: () => imageClassification,\n  imageSegmentation: () => imageSegmentation,\n  imageToImage: () => imageToImage,\n  imageToText: () => imageToText,\n  objectDetection: () => objectDetection,\n  questionAnswering: () => questionAnswering,\n  request: () => request,\n  sentenceSimilarity: () => sentenceSimilarity,\n  streamingRequest: () => streamingRequest,\n  summarization: () => summarization,\n  tableQuestionAnswering: () => tableQuestionAnswering,\n  tabularClassification: () => tabularClassification,\n  tabularRegression: () => tabularRegression,\n  textClassification: () => textClassification,\n  textGeneration: () => textGeneration,\n  textGenerationStream: () => textGenerationStream,\n  textToImage: () => textToImage,\n  textToSpeech: () => textToSpeech,\n  tokenClassification: () => tokenClassification,\n  translation: () => translation,\n  visualQuestionAnswering: () => visualQuestionAnswering,\n  zeroShotClassification: () => zeroShotClassification,\n  zeroShotImageClassification: () => zeroShotImageClassification\n});\n\n// src/utils/pick.ts\nfunction pick(o, props) {\n  return Object.assign(\n    {},\n    ...props.map((prop) => {\n      if (o[prop] !== void 0) {\n        return { [prop]: o[prop] };\n      }\n    })\n  );\n}\n\n// src/utils/typedInclude.ts\nfunction typedInclude(arr, v) {\n  return arr.includes(v);\n}\n\n// src/utils/omit.ts\nfunction omit(o, props) {\n  const propsArr = Array.isArray(props) ? props : [props];\n  const letsKeep = Object.keys(o).filter((prop) => !typedInclude(propsArr, prop));\n  return pick(o, letsKeep);\n}\n\n// src/lib/isUrl.ts\nfunction isUrl(modelOrUrl) {\n  return /^http(s?):/.test(modelOrUrl) || modelOrUrl.startsWith(\"/\");\n}\n\n// src/lib/getDefaultTask.ts\nvar taskCache = /* @__PURE__ */ new Map();\nvar CACHE_DURATION = 10 * 60 * 1e3;\nvar MAX_CACHE_ITEMS = 1e3;\nvar HF_HUB_URL = \"https://huggingface.co\";\nasync function getDefaultTask(model, accessToken, options) {\n  if (isUrl(model)) {\n    return null;\n  }\n  const key = `${model}:${accessToken}`;\n  let cachedTask = taskCache.get(key);\n  if (cachedTask && cachedTask.date < new Date(Date.now() - CACHE_DURATION)) {\n    taskCache.delete(key);\n    cachedTask = void 0;\n  }\n  if (cachedTask === void 0) {\n    const modelTask = await (options?.fetch ?? fetch)(`${HF_HUB_URL}/api/models/${model}?expand[]=pipeline_tag`, {\n      headers: accessToken ? { Authorization: `Bearer ${accessToken}` } : {}\n    }).then((resp) => resp.json()).then((json) => json.pipeline_tag).catch(() => null);\n    if (!modelTask) {\n      return null;\n    }\n    cachedTask = { task: modelTask, date: /* @__PURE__ */ new Date() };\n    taskCache.set(key, { task: modelTask, date: /* @__PURE__ */ new Date() });\n    if (taskCache.size > MAX_CACHE_ITEMS) {\n      taskCache.delete(taskCache.keys().next().value);\n    }\n  }\n  return cachedTask.task;\n}\n\n// src/lib/makeRequestOptions.ts\nvar HF_INFERENCE_API_BASE_URL = \"https://api-inference.huggingface.co\";\nvar tasks = null;\nasync function makeRequestOptions(args, options) {\n  const { accessToken, endpointUrl, ...otherArgs } = args;\n  let { model } = args;\n  const {\n    forceTask: task,\n    includeCredentials,\n    taskHint,\n    wait_for_model,\n    use_cache,\n    dont_load_model,\n    chatCompletion: chatCompletion2\n  } = options ?? {};\n  const headers = {};\n  if (accessToken) {\n    headers[\"Authorization\"] = `Bearer ${accessToken}`;\n  }\n  if (!model && !tasks && taskHint) {\n    const res = await fetch(`${HF_HUB_URL}/api/tasks`);\n    if (res.ok) {\n      tasks = await res.json();\n    }\n  }\n  if (!model && tasks && taskHint) {\n    const taskInfo = tasks[taskHint];\n    if (taskInfo) {\n      model = taskInfo.models[0].id;\n    }\n  }\n  if (!model) {\n    throw new Error(\"No model provided, and no default model found for this task\");\n  }\n  const binary = \"data\" in args && !!args.data;\n  if (!binary) {\n    headers[\"Content-Type\"] = \"application/json\";\n  }\n  if (wait_for_model) {\n    headers[\"X-Wait-For-Model\"] = \"true\";\n  }\n  if (use_cache === false) {\n    headers[\"X-Use-Cache\"] = \"false\";\n  }\n  if (dont_load_model) {\n    headers[\"X-Load-Model\"] = \"0\";\n  }\n  let url = (() => {\n    if (endpointUrl && isUrl(model)) {\n      throw new TypeError(\"Both model and endpointUrl cannot be URLs\");\n    }\n    if (isUrl(model)) {\n      console.warn(\"Using a model URL is deprecated, please use the `endpointUrl` parameter instead\");\n      return model;\n    }\n    if (endpointUrl) {\n      return endpointUrl;\n    }\n    if (task) {\n      return `${HF_INFERENCE_API_BASE_URL}/pipeline/${task}/${model}`;\n    }\n    return `${HF_INFERENCE_API_BASE_URL}/models/${model}`;\n  })();\n  if (chatCompletion2 && !url.endsWith(\"/chat/completions\")) {\n    url += \"/v1/chat/completions\";\n  }\n  let credentials;\n  if (typeof includeCredentials === \"string\") {\n    credentials = includeCredentials;\n  } else if (includeCredentials === true) {\n    credentials = \"include\";\n  }\n  const info = {\n    headers,\n    method: \"POST\",\n    body: binary ? args.data : JSON.stringify({\n      ...otherArgs.model && isUrl(otherArgs.model) ? omit(otherArgs, \"model\") : otherArgs\n    }),\n    ...credentials && { credentials },\n    signal: options?.signal\n  };\n  return { url, info };\n}\n\n// src/tasks/custom/request.ts\nasync function request(args, options) {\n  const { url, info } = await makeRequestOptions(args, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return request(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(JSON.stringify(output.error));\n      }\n    }\n    throw new Error(\"An error occurred while fetching the blob\");\n  }\n  if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n    return await response.json();\n  }\n  return await response.blob();\n}\n\n// src/vendor/fetch-event-source/parse.ts\nfunction getLines(onLine) {\n  let buffer;\n  let position;\n  let fieldLength;\n  let discardTrailingNewline = false;\n  return function onChunk(arr) {\n    if (buffer === void 0) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      buffer = concat(buffer, arr);\n    }\n    const bufLength = buffer.length;\n    let lineStart = 0;\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10 /* NewLine */) {\n          lineStart = ++position;\n        }\n        discardTrailingNewline = false;\n      }\n      let lineEnd = -1;\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58 /* Colon */:\n            if (fieldLength === -1) {\n              fieldLength = position - lineStart;\n            }\n            break;\n          case 13 /* CarriageReturn */:\n            discardTrailingNewline = true;\n          case 10 /* NewLine */:\n            lineEnd = position;\n            break;\n        }\n      }\n      if (lineEnd === -1) {\n        break;\n      }\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position;\n      fieldLength = -1;\n    }\n    if (lineStart === bufLength) {\n      buffer = void 0;\n    } else if (lineStart !== 0) {\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\nfunction getMessages(onId, onRetry, onMessage) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n  return function onLine(line, fieldLength) {\n    if (line.length === 0) {\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 /* Space */ ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId(message.id = value);\n          break;\n        case \"retry\":\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            onRetry(message.retry = retry);\n          }\n          break;\n      }\n    }\n  };\n}\nfunction concat(a, b) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\nfunction newMessage() {\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: void 0\n  };\n}\n\n// src/tasks/custom/streamingRequest.ts\nasync function* streamingRequest(args, options) {\n  const { url, info } = await makeRequestOptions({ ...args, stream: true }, options);\n  const response = await (options?.fetch ?? fetch)(url, info);\n  if (options?.retry_on_error !== false && response.status === 503 && !options?.wait_for_model) {\n    return yield* streamingRequest(args, {\n      ...options,\n      wait_for_model: true\n    });\n  }\n  if (!response.ok) {\n    if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\n      const output = await response.json();\n      if ([400, 422, 404, 500].includes(response.status) && options?.chatCompletion) {\n        throw new Error(`Server ${args.model} does not seem to support chat completion. Error: ${output.error}`);\n      }\n      if (output.error) {\n        throw new Error(output.error);\n      }\n    }\n    throw new Error(`Server response contains error: ${response.status}`);\n  }\n  if (!response.headers.get(\"content-type\")?.startsWith(\"text/event-stream\")) {\n    throw new Error(\n      `Server does not support event stream content type, it returned ` + response.headers.get(\"content-type\")\n    );\n  }\n  if (!response.body) {\n    return;\n  }\n  const reader = response.body.getReader();\n  let events = [];\n  const onEvent = (event) => {\n    events.push(event);\n  };\n  const onChunk = getLines(\n    getMessages(\n      () => {\n      },\n      () => {\n      },\n      onEvent\n    )\n  );\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done)\n        return;\n      onChunk(value);\n      for (const event of events) {\n        if (event.data.length > 0) {\n          if (event.data === \"[DONE]\") {\n            return;\n          }\n          const data = JSON.parse(event.data);\n          if (typeof data === \"object\" && data !== null && \"error\" in data) {\n            throw new Error(data.error);\n          }\n          yield data;\n        }\n      }\n      events = [];\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/lib/InferenceOutputError.ts\nvar InferenceOutputError = class extends TypeError {\n  constructor(message) {\n    super(\n      `Invalid inference output: ${message}. Use the 'request' method with the same parameters to do a custom call with no type checking.`\n    );\n    this.name = \"InferenceOutputError\";\n  }\n};\n\n// src/tasks/audio/audioClassification.ts\nasync function audioClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/audio/automaticSpeechRecognition.ts\nasync function automaticSpeechRecognition(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"automatic-speech-recognition\"\n  });\n  const isValidOutput = typeof res?.text === \"string\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/audio/textToSpeech.ts\nasync function textToSpeech(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-speech\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/audio/audioToAudio.ts\nasync function audioToAudio(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"audio-to-audio\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.blob === \"string\" && typeof x[\"content-type\"] === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, blob: string, content-type: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageClassification.ts\nasync function imageClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageSegmentation.ts\nasync function imageSegmentation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"image-segmentation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.mask === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, mask: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/cv/imageToText.ts\nasync function imageToText(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"image-to-text\"\n  }))?.[0];\n  if (typeof res?.generated_text !== \"string\") {\n    throw new InferenceOutputError(\"Expected {generated_text: string}\");\n  }\n  return res;\n}\n\n// src/tasks/cv/objectDetection.ts\nasync function objectDetection(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"object-detection\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.label === \"string\" && typeof x.score === \"number\" && typeof x.box.xmin === \"number\" && typeof x.box.ymin === \"number\" && typeof x.box.xmax === \"number\" && typeof x.box.ymax === \"number\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{label:string; score:number; box:{xmin:number; ymin:number; xmax:number; ymax:number}}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/cv/textToImage.ts\nasync function textToImage(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/utils/base64FromBytes.ts\nfunction base64FromBytes(arr) {\n  if (globalThis.Buffer) {\n    return globalThis.Buffer.from(arr).toString(\"base64\");\n  } else {\n    const bin = [];\n    arr.forEach((byte) => {\n      bin.push(String.fromCharCode(byte));\n    });\n    return globalThis.btoa(bin.join(\"\"));\n  }\n}\n\n// src/tasks/cv/imageToImage.ts\nasync function imageToImage(args, options) {\n  let reqArgs;\n  if (!args.parameters) {\n    reqArgs = {\n      accessToken: args.accessToken,\n      model: args.model,\n      data: args.inputs\n    };\n  } else {\n    reqArgs = {\n      ...args,\n      inputs: base64FromBytes(\n        new Uint8Array(args.inputs instanceof ArrayBuffer ? args.inputs : await args.inputs.arrayBuffer())\n      )\n    };\n  }\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"image-to-image\"\n  });\n  const isValidOutput = res && res instanceof Blob;\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Blob\");\n  }\n  return res;\n}\n\n// src/tasks/cv/zeroShotImageClassification.ts\nasync function zeroShotImageClassification(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = await request(reqArgs, {\n    ...options,\n    taskHint: \"zero-shot-image-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/featureExtraction.ts\nasync function featureExtraction(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"feature-extraction\",\n    ...defaultTask === \"sentence-similarity\" && { forceTask: \"feature-extraction\" }\n  });\n  let isValidOutput = true;\n  const isNumArrayRec = (arr, maxDepth, curDepth = 0) => {\n    if (curDepth > maxDepth)\n      return false;\n    if (arr.every((x) => Array.isArray(x))) {\n      return arr.every((x) => isNumArrayRec(x, maxDepth, curDepth + 1));\n    } else {\n      return arr.every((x) => typeof x === \"number\");\n    }\n  };\n  isValidOutput = Array.isArray(res) && isNumArrayRec(res, 3, 0);\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<number[][][] | number[][] | number[] | number>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/fillMask.ts\nasync function fillMask(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"fill-mask\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.score === \"number\" && typeof x.sequence === \"string\" && typeof x.token === \"number\" && typeof x.token_str === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{score: number, sequence: string, token: number, token_str: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/questionAnswering.ts\nasync function questionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"question-answering\"\n  });\n  const isValidOutput = typeof res === \"object\" && !!res && typeof res.answer === \"string\" && typeof res.end === \"number\" && typeof res.score === \"number\" && typeof res.start === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected {answer: string, end: number, score: number, start: number}\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/sentenceSimilarity.ts\nasync function sentenceSimilarity(args, options) {\n  const defaultTask = args.model ? await getDefaultTask(args.model, args.accessToken, options) : void 0;\n  const res = await request(args, {\n    ...options,\n    taskHint: \"sentence-similarity\",\n    ...defaultTask === \"feature-extraction\" && { forceTask: \"sentence-similarity\" }\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/summarization.ts\nasync function summarization(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"summarization\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.summary_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{summary_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/tableQuestionAnswering.ts\nasync function tableQuestionAnswering(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"table-question-answering\"\n  });\n  const isValidOutput = typeof res?.aggregator === \"string\" && typeof res.answer === \"string\" && Array.isArray(res.cells) && res.cells.every((x) => typeof x === \"string\") && Array.isArray(res.coordinates) && res.coordinates.every((coord) => Array.isArray(coord) && coord.every((x) => typeof x === \"number\"));\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected {aggregator: string, answer: string, cells: string[], coordinates: number[][]}\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/textClassification.ts\nasync function textClassification(args, options) {\n  const res = (await request(args, {\n    ...options,\n    taskHint: \"text-classification\"\n  }))?.[0];\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.label === \"string\" && typeof x.score === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{label: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/utils/toArray.ts\nfunction toArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return [obj];\n}\n\n// src/tasks/nlp/textGeneration.ts\nasync function textGeneration(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"text-generation\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.generated_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{generated_text: string}>\");\n  }\n  return res?.[0];\n}\n\n// src/tasks/nlp/textGenerationStream.ts\nasync function* textGenerationStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\"\n  });\n}\n\n// src/tasks/nlp/tokenClassification.ts\nasync function tokenClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"token-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => typeof x.end === \"number\" && typeof x.entity_group === \"string\" && typeof x.score === \"number\" && typeof x.start === \"number\" && typeof x.word === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\n      \"Expected Array<{end: number, entity_group: string, score: number, start: number, word: string}>\"\n    );\n  }\n  return res;\n}\n\n// src/tasks/nlp/translation.ts\nasync function translation(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"translation\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x?.translation_text === \"string\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected type Array<{translation_text: string}>\");\n  }\n  return res?.length === 1 ? res?.[0] : res;\n}\n\n// src/tasks/nlp/zeroShotClassification.ts\nasync function zeroShotClassification(args, options) {\n  const res = toArray(\n    await request(args, {\n      ...options,\n      taskHint: \"zero-shot-classification\"\n    })\n  );\n  const isValidOutput = Array.isArray(res) && res.every(\n    (x) => Array.isArray(x.labels) && x.labels.every((_label) => typeof _label === \"string\") && Array.isArray(x.scores) && x.scores.every((_score) => typeof _score === \"number\") && typeof x.sequence === \"string\"\n  );\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{labels: string[], scores: number[], sequence: string}>\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletion.ts\nasync function chatCompletion(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n  const isValidOutput = typeof res === \"object\" && Array.isArray(res?.choices) && typeof res?.created === \"number\" && typeof res?.id === \"string\" && typeof res?.model === \"string\" && typeof res?.system_fingerprint === \"string\" && typeof res?.usage === \"object\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected ChatCompletionOutput\");\n  }\n  return res;\n}\n\n// src/tasks/nlp/chatCompletionStream.ts\nasync function* chatCompletionStream(args, options) {\n  yield* streamingRequest(args, {\n    ...options,\n    taskHint: \"text-generation\",\n    chatCompletion: true\n  });\n}\n\n// src/tasks/multimodal/documentQuestionAnswering.ts\nasync function documentQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = toArray(\n    await request(reqArgs, {\n      ...options,\n      taskHint: \"document-question-answering\"\n    })\n  )?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && (typeof res.end === \"number\" || typeof res.end === \"undefined\") && (typeof res.score === \"number\" || typeof res.score === \"undefined\") && (typeof res.start === \"number\" || typeof res.start === \"undefined\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, end?: number, score?: number, start?: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/multimodal/visualQuestionAnswering.ts\nasync function visualQuestionAnswering(args, options) {\n  const reqArgs = {\n    ...args,\n    inputs: {\n      question: args.inputs.question,\n      // convert Blob or ArrayBuffer to base64\n      image: base64FromBytes(\n        new Uint8Array(\n          args.inputs.image instanceof ArrayBuffer ? args.inputs.image : await args.inputs.image.arrayBuffer()\n        )\n      )\n    }\n  };\n  const res = (await request(reqArgs, {\n    ...options,\n    taskHint: \"visual-question-answering\"\n  }))?.[0];\n  const isValidOutput = typeof res?.answer === \"string\" && typeof res.score === \"number\";\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected Array<{answer: string, score: number}>\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularRegression.ts\nasync function tabularRegression(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-regression\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/tasks/tabular/tabularClassification.ts\nasync function tabularClassification(args, options) {\n  const res = await request(args, {\n    ...options,\n    taskHint: \"tabular-classification\"\n  });\n  const isValidOutput = Array.isArray(res) && res.every((x) => typeof x === \"number\");\n  if (!isValidOutput) {\n    throw new InferenceOutputError(\"Expected number[]\");\n  }\n  return res;\n}\n\n// src/HfInference.ts\nvar HfInference = class {\n  accessToken;\n  defaultOptions;\n  constructor(accessToken = \"\", defaultOptions = {}) {\n    this.accessToken = accessToken;\n    this.defaultOptions = defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n  /**\n   * Returns copy of HfInference tied to a specified endpoint.\n   */\n  endpoint(endpointUrl) {\n    return new HfInferenceEndpoint(endpointUrl, this.accessToken, this.defaultOptions);\n  }\n};\nvar HfInferenceEndpoint = class {\n  constructor(endpointUrl, accessToken = \"\", defaultOptions = {}) {\n    accessToken;\n    defaultOptions;\n    for (const [name, fn] of Object.entries(tasks_exports)) {\n      Object.defineProperty(this, name, {\n        enumerable: false,\n        value: (params, options) => (\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          fn({ ...params, accessToken, endpointUrl }, { ...defaultOptions, ...options })\n        )\n      });\n    }\n  }\n};\nexport {\n  HfInference,\n  HfInferenceEndpoint,\n  InferenceOutputError,\n  audioClassification,\n  audioToAudio,\n  automaticSpeechRecognition,\n  chatCompletion,\n  chatCompletionStream,\n  documentQuestionAnswering,\n  featureExtraction,\n  fillMask,\n  imageClassification,\n  imageSegmentation,\n  imageToImage,\n  imageToText,\n  objectDetection,\n  questionAnswering,\n  request,\n  sentenceSimilarity,\n  streamingRequest,\n  summarization,\n  tableQuestionAnswering,\n  tabularClassification,\n  tabularRegression,\n  textClassification,\n  textGeneration,\n  textGenerationStream,\n  textToImage,\n  textToSpeech,\n  tokenClassification,\n  translation,\n  visualQuestionAnswering,\n  zeroShotClassification,\n  zeroShotImageClassification\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}